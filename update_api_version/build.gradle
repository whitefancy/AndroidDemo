plugins {
    id 'com.android.application'
}
//Gradle 构建配置文件
//让依赖项配置针对特定构建
//如果您希望某个依赖项仅用于特定的构建变体源代码集或测试源代码集，
// 请将依赖项配置名称首字母大写，并在其前面加上构建变体或测试源代码集的名称作为前缀。
//android {...}
//// Creates Gradle dependency configurations to use in the dependencies block.
//configurations {
//    // For variants that combine a product flavor and build type, you need to
//    // intitialize a placeholder for its dependency configuration.
//    freeDebugRuntimeOnly{}
//    ...
//}
//dependencies {
//    // Adds an implementation dependency only to the "free" product flavor.
//    freeImplementation 'com.google.firebase:firebase-ads:9.8.0'
//    // Adds a runtimeOnly dependency only to the "freeDebug" build variant.
//    freeDebugRuntimeOnly fileTree(dir: 'libs', include: ['*.jar'])
//    // Adds a remote binary dependency only for local tests.
//    testImplementation 'junit:junit:4.12'
//    // Adds a remote binary dependency only for the instrumented test APK.
//    androidTestImplementation 'com.android.support.test.espresso:espresso-core:3.0.2'
//}

android {
    //compileSDKVersion
    //compileSDKVersion定义应用程序编译选择哪个Android SDK版本，通常设置为最新的API版本，
    // 它的属性值不会影响Android系统运行行为，仅仅是Android编译项目时其中的一项配置，不会打包到APK中，
    // 其目的是为了 在编译的时候检查代码的错误的警告，提示开发者修改和优化。
    compileSdkVersion 30
    buildToolsVersion "30.0.3"

    defaultConfig {
        applicationId "pub.whitefancy.androiddemo"

        //minSdkVersion
        //minSdkVersion定义应用支持安装的最低Android版本，这个数值有两个作用：
        //告诉Google Play Store哪些Android版本的手机可以安装该APK。
        //默认情况下，lint会对代码中的API调用做出提示，假如你调用的API是在minSdkVersion之后才提供的，那么它会告诉你，虽然可以编译通过，但是会在运行的时候抛出异常。
        //如果调用的API是在minSdkVersion之后才提供的，解决的方案有两种：
        //运行时判断API Level，仅在足够高，有此方法的API Level系统中调用此方法。
        //if (android.os.Build.VERSION.SDK_INT >= Build.VERSION_CODES.M) {
        // //处理逻辑。
        //}
        //保证功能完整性，通过低版本的API实现功能。
        minSdkVersion 19
        //在运行时检查系统版本
        //Android 会在 Build 常量类中为每个平台版本提供一个唯一的代码。请在您的应用内使用这些代码构建条件，以确保那些依赖更高 API 级别的代码仅在系统上提供这些 API 时才会执行。
        //注意：解析 XML 资源时，Android 会忽略当前设备不支持的 XML 属性。
        // 因此您可以放心地使用只有新版系统才支持的 XML 属性，无需担心旧版系统遇到该代码时会中断执行。
        // 例如，如果您设置了 targetSdkVersion="11"，默认情况下您的应用在 Android 3.0 及更高版本的系统上
        // 才会包含 ActionBar。之后如需为操作栏添加菜单项，
        // 则需在您的菜单资源 XML 中设置 android:showAsAction="ifRoom"。
        // 您可以放心地在跨版本 XML 文件中执行此操作，因为旧版 Android 会直接忽略 showAsAction 属性（
        // 也就是说，您不需要在 res/menu-v11/ 中单独提供一个版本）。
        //targetSdkVersion 有什么用
        //每个Android版本都会对应一个API数字，例如Android 7.0对应的是API 24，当手机的Android系统版本升级的时候，会出现两种情况：
        //提供了新的接口。如果开发者想要在APP中使用Android 7.0提供的新功能，除了需要使用Android 7.0手机，还需要保证targetSdkVersion升级到至少24，从这个角度来说，升级 targetSdkVersion 的目的是为了使用新版本的功能。
        //旧接口的行为发生了变化。为了保证旧的APK的行为还是和以前兼容，在源码当中，有许多类似于ctx.getApplicationInfo().targetSdkVersion的判断。因此只要APK的targetSdkVersion不变，即使这个APK安装在新的Android系统上，其行为也不会发生变化，从这个角度来说，targetSdkVersion 保证了系统对旧应用的向前兼容性。
        //        如何利用最新 API，同时继续为旧版 API 提供支持。
//平台版本信息中心会定期更新，以根据访问 Google Play 商店的设备数量显示搭载 Android 各版本的活跃设备分布情况。
// 一般而言，在针对最新版本开发应用的同时，最好使应用能够支持大约 90% 的活跃设备。
//随着 Android 新版本的发布，某些样式和行为可能会发生变化。
// 为让您的应用能够充分利用这些变化并确保其适应各类用户设备的样式，
// 您应将 targetSdkVersion 值设置为与市场上最新的 Android 版本一致。
        targetSdkVersion 30
        versionCode 1
        versionName "1.0"
//        添加多密度矢量图形的好处是使用矢量图代替位图可以减小 APK 的尺寸，
//        因为可以针对不同屏幕密度调整同一文件的大小，而不会降低图像质量。
//        对于不支持矢量图的较早版本 Android 系统，Vector Asset Studio
//        可在构建时针对每种屏幕密度将矢量图转换为不同大小的位图。
        vectorDrawables.useSupportLibrary = true
    }
//从Android studio 3.0 之后 lib依赖model build.gradle 里面 buildConfig 节点中的配置项必须和
//主工程app下build.gradle 中配置的一样 如：
//buildTypes {
// debug {
// ....//我自己项目中的配置
// }
// beta {
// ....//我自己项目中的配置
// }
// release {
// ....//我自己项目中的配置
// }
// }
// 那么引用的model中的配置也必须保持一致
    buildTypes {
        release {
            minifyEnabled false
            proguardFiles getDefaultProguardFile('proguard-android-optimize.txt'), 'proguard-rules.pro'
        }
    }
    compileOptions {
        sourceCompatibility JavaVersion.VERSION_1_8
        targetCompatibility JavaVersion.VERSION_1_8
    }
}

dependencies {

    implementation 'androidx.appcompat:appcompat:1.3.1'
    implementation 'com.google.android.material:material:1.4.0'
    implementation 'androidx.constraintlayout:constraintlayout:2.1.0'
    implementation 'androidx.navigation:navigation-fragment:2.3.5'
    implementation 'androidx.navigation:navigation-ui:2.3.5'
}
//多环境打包的时候
//我们之前是这么写的
//android.applicationVariants.all { variant ->
// variant.outputs.each { output ->
// def outputFile = output.outputFile
// if (outputFile != null && outputFile.name.endsWith('.apk')) {
// //这里修改apk文件名
// def fileName = "app-release.apk"
// output.outputFile = new File(outputFile.parent, fileName)
// }
// }
// }
//在新的gradle上面会报错 outputFile 找不到
//修改如下
//android.applicationVariants.all { variant ->
// variant.outputs.all {
// //这里修改apk文件名
// outputFileName = "app-release.apk"
// }
//}
android.applicationVariants.all { variant ->
    variant.outputs.all {
        //这里修改apk文件名
        outputFileName = "app-release.apk"
    }
}
//按屏幕密度配置单独的 APK
//如需为不同的屏幕密度创建单独的 APK，请将 android.splits.density 代码块添加到模块的 build.gradle 文件中。
//android {
//  ...
//  splits {
//    // Configures multiple APKs based on screen density.
//    density {
//      // Enables building multiple APKs.
//      enable true
//      // Specifies a list of screen densities Gradle should not create APKs for.
//      exclude "ldpi", "mdpi"
//      // Alternatively, you can use the following to clear the default list of
//      // screen densities and specify only the screen densities you want to build
//      // APKs for:
//      // reset()
//      // include "hdpi", "xhdpi", "xxhdpi", "xxxhdpi"
//      // Specifies a list of compatible screen size settings. This property
//      // configures the <compatible-screens> element in the manifest. You
//      // typically don't need to configure this manifest property, but it's
//      // important when building multiple APKs based on screen density.
//      compatibleScreens 'normal', 'large', 'xlarge'
//    }
//  }
//}
//按 ABI 配置单独的 APK
//如需为每个 ABI 创建单独的 APK，请将 android.splits.abi 代码块添加到模块的 build.gradle 文件中。
//android {
//  ...
//  splits {
//    // Configures multiple APKs based on ABI.
//    abi {
//      // Enables building multiple APKs.
//      enable true
//      // By default all ABIs are included, so use reset() and include to specify that we only
//      // want APKs for x86, armeabi-v7a, and mips.
//      reset()
//      // Specifies a list of ABIs that Gradle should create APKs for.
//      include "x86", "armeabi-v7a", "mips"
//      // Specify that we want to also generate a universal APK that includes all ABIs.
//      universalApk true
//    }
//  }
//}
//配置动态版本代码
//默认情况下，在 Gradle 为项目生成 APK 时，每个 APK 都有相同的版本信息，该信息在模块级 build.gradle 文件中指定。由于 Google Play 商店不允许同一个应用的多个 APK 全都具有相同的版本信息，因此在上传到 Play 商店之前，您需要确保每个 APK 都有自己唯一的 versionCode。
//为此，您可以使用自定义构建逻辑，在构建时向每个 APK 分配不同的版本代码。例如，在为每个 ABI 创建单独的 APK 时，自动 APK 版本控制将如下所示：
//android {
//  ...
//  defaultConfig {
//    ...
//    versionCode 4
//  }
//  splits {
//    ...
//  }
//}
//// Map for the version code that gives each ABI a value.
//ext.abiCodes = ['armeabi-v7a':1, mips:2, x86:3]
//// For per-density APKs, create a similar map like this:
//// ext.densityCodes = ['hdpi': 1, 'xhdpi': 2, 'xxhdpi': 3, 'xxxhdpi': 4]
//import com.android.build.OutputFile
//// For each APK output variant, override versionCode with a combination of
//// ext.abiCodes * 1000 + variant.versionCode. In this example, variant.versionCode
//// is equal to defaultConfig.versionCode. If you configure product flavors that
//// define their own versionCode, variant.versionCode uses that value instead.
//android.applicationVariants.all { variant ->
//  // Assigns a different version code for each output APK
//  // other than the universal APK.
//  variant.outputs.each { output ->
//    // Stores the value of ext.abiCodes that is associated with the ABI for this variant.
//    def baseAbiVersionCode =
//            // Determines the ABI for this variant and returns the mapped value.
//            project.ext.abiCodes.get(output.getFilter(OutputFile.ABI))
//    // Because abiCodes.get() returns null for ABIs that are not mapped by ext.abiCodes,
//    // the following code does not override the version code for universal APKs.
//    // However, because we want universal APKs to have the lowest version code,
//    // this outcome is desirable.
//    if (baseAbiVersionCode != null) {
//      // Assigns the new version code to versionCodeOverride, which changes the version code
//      // for only the output APK, not for the variant itself. Skipping this step simply
//      // causes Gradle to use the value of variant.versionCode for the APK.
//      output.versionCodeOverride =
//              baseAbiVersionCode * 1000 + variant.versionCode
//    }
//  }
//}
//组合多个产品变种
//the first dimension has a higher priority than the second, and so on.
//flavorDimensions "api", "mode"
//过滤变体
//您可以使用模块的 build.gradle 文件中的 variantFilter 代码块过滤构建变体，将您不想要的变体过滤掉。以下示例代码指示 Gradle 不构建任何将“minApi21”和“demo”产品变种组合在一起的变体：
//android {
// ...
// buildTypes {...}
// flavorDimensions "api", "mode"
// productFlavors {
//    demo {...}
//    full {...}
//    minApi24 {...}
//    minApi23 {...}
//    minApi21 {...}
//  }
//  variantFilter { variant ->
//    def names = variant.flavors*.name
//    // To check for a build type instead, use variant.buildType.name == "buildType"
//    if (names.contains("minApi21") && names.contains("demo")) {
//      // Gradle ignores any variants that satisfy the conditions above.
//      setIgnore(true)
//    }
//  }
//}
//更改测试构建类型
//默认情况下，所有测试均针对调试构建类型运行。您可以使用模块级 build.gradle 文件中的 testBuildType 属性将其更改为针对其他构建类型运行。例如，如果您要针对“staging”构建类型运行测试，请按以下代码段所示对该文件进行修改。
//android {
//    ...
//    testBuildType "staging"
//}

//优化构建过程
//s缩减代码
//Android Studio 使用 R8（它使用 ProGuard 规则文件）缩减代码。对于新项目，Android Studio 将使用 Android SDK 的 tools/proguard/folder 中的默认设置文件 (proguard-android.txt)。如需进一步缩减代码，请尝试使用位于同一位置的 proguard-android-optimize.txt 文件。
//android {
//  buildTypes {
//    release {
//      minifyEnabled true
//      proguardFiles getDefaultProguardFile('proguard-android-optimize.txt'),
//                                           'proguard-rules.pro'
//    }
//  }
//  ...
//}
//...
//如需添加特定于每个构建变体的规则，请为每个变种分别配置额外的 proguardFiles 属性。例如，以下示例将 flavor2-rules.pro 添加到“flavor2”。现在，“flavor2”的发布版本使用全部三个规则文件，因为该变种还应用了 release 代码块中的规则文件。
//android {
//  ...
//  buildTypes {
//    release {
//      minifyEnabled true
//      proguardFiles getDefaultProguardFile('proguard-android.txt'),
//             'proguard-rules.pro'
//    }
//  }
//  productFlavors {
//    flavor1 {
//      ...
//    }
//    flavor2 {
//      proguardFile 'flavor2-rules.pro'
//    }
//  }
//}
//发布应用
//为您的应用签名
//虽然 Android Studio 提供了一种从界面中为发布 build 配置签名的简单方式，但您也可以手动配置模块的 build.gradle 文件中的 signingConfigs 代码块：
//android {
//  ...
//  defaultConfig { ... }
//  // Encapsulates signing configurations.
//  signingConfigs {
//    // Creates a signing configuration called "release".
//    release {
//      // Specifies the path to your keystore file.
//      storeFile file("my-release-key.jks")
//      // Specifies the password for your keystore.
//      storePassword "password"
//      // Specifies the identifying name for your key.
//      keyAlias "my-alias"
//      // Specifies the password for your key.
//      keyPassword "password"
//    }
//  }
//  buildTypes {
//    release {
//      // Adds the "release" signing configuration to the release build type.
//      signingConfig signingConfigs.release
//      ...
//    }
//  }
//}
//...
//signingConfigs {
//        release {
//            File strFile = new File("../jks/VC.jks")
//            storeFile file(strFile)
//            storePassword "vc1234"
//            keyPassword "vc1234"
//            keyAlias "vc"
//        }
//    }
//2、
//signingConfigs {
//        release {
//            storeFile file(RELEASE_STOREFILE);
//            storePassword RELEASE_STORE_PASSWORD;
//            keyAlias RELEASE_KEY_ALIAS
//            keyPassword RELEASE_KEY_PASSWORD
//        }
//    }
// buildTypes {
//        release {
//            minifyEnabled true   //是否代码混淆
//            multiDexEnabled true //防止方法数量超过65536导致错误
//            proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro'
//            signingConfig signingConfigs.release
//        }
// }
//从项目中移除私密签名信息
//默认情况下，签名配置将以纯文本形式记录到模块的 build.gradle 文件中。如果您正在与某个团队合作或正在参与某个开源项目，可以执行以下步骤，将此敏感信息从构建文件中移出。
//在项目的根目录下创建一个名为 keystore.properties 的文件，并使其包含以下信息：
//storePassword=myStorePassword
//keyPassword=myKeyPassword
//keyAlias=myKeyAlias
//storeFile=myStoreFileLocation
//在 build.gradle 文件中，按如下方式加载 keystore.properties 文件（必须在 android 代码块前面）：
//// Creates a variable called keystorePropertiesFile, and initializes it to the
//// keystore.properties file.
//def keystorePropertiesFile = rootProject.file("keystore.properties")
//// Initializes a new Properties() object called keystoreProperties.
//def keystoreProperties = new Properties()
//// Loads the keystore.properties file into the keystoreProperties object.
//keystoreProperties.load(new FileInputStream(keystorePropertiesFile))
//android {
//  ...
//}
//...
//输入存储在 keystoreProperties 对象中的签名信息：
//android {
//  signingConfigs {
//    config {
//      keyAlias keystoreProperties['keyAlias']
//      keyPassword keystoreProperties['keyPassword']
//      storeFile file(keystoreProperties['storeFile'])
//      storePassword keystoreProperties['storePassword']
//    }
//  }
//  ...
//}
//...
//点击通知栏中的立即同步。

//简化应用开发
//g与应用代码共享自定义字段和资源值
//在构建时，Gradle 将生成 BuildConfig 类，以便应用代码可以检查与当前构建有关的信息。您也可以从 Gradle 构建配置文件中使用 buildConfigField() 方法将自定义字段添加到 BuildConfig 类中，然后在应用的运行时代码中访问这些值。同样，您也可以使用 resValue() 添加应用资源值。
//android {
//  ...
//  buildTypes {
//    release {
//      // These values are defined only for the release build, which
//      // is typically used for full builds and continuous builds.
//      buildConfigField("String", "BUILD_TIME", "\"${minutesSinceEpoch}\"")
//      resValue("string", "build_time", "${minutesSinceEpoch}")
//      ...
//    }
//    debug {
//      // Use static values for incremental builds to ensure that
//      // resource files and BuildConfig aren't rebuilt with each run.
//      // If these rebuild dynamically, they can interfere with
//      // Apply Changes as well as Gradle UP-TO-DATE checks.
//      buildConfigField("String", "BUILD_TIME", "\"0\"")
//      resValue("string", "build_time", "0")
//    }
//  }
//}
//buildTypes {
//        debug{}
//        release {}
//    }
//    productFlavors {
//        vanillaDebug {
//             buildConfigField BOOLEAN, VARIABLE, FALSE
//        }
//        vanillaRelease {
//             buildConfigField BOOLEAN, VARIABLE, TRUE
//        }
//        chocolate {
//             buildConfigField BOOLEAN, VARIABLE, FALSE
//        }
//    }
//在应用代码中，您可以按如下方式访问属性：
//Log.i(TAG, BuildConfig.BUILD_TIME);
//Log.i(TAG, getString(R.string.build_time));
//android {
//    buildTypes {
//        debug {
//            buildConfigField "int", "FOO", "42"
//            buildConfigField "String", "FOO_STRING", "\"foo\""
//            buildConfigField "boolean", "LOG", "true"
//        }
//        release {
//            buildConfigField "int", "FOO", "52"
//            buildConfigField "String", "FOO_STRING", "\"bar\""
//            buildConfigField "boolean", "LOG", "false"
//        }
//    }
//}
//You can access them with BuildConfig.FOO
//Generate Android resources
//android {
//    buildTypes {
//        debug{
//            resValue "string", "app_name", "My App Name Debug"
//        }
//        release {
//            resValue "string", "app_name", "My App Name"
//        }
//    }
//}
//You can access them in the usual way with @string/app_name or R.string.app_name
//与清单共享属性
//s在某些情况下，您可能需要同时在清单和代码中声明同一属性（例如，在声明 FileProvider 的授权机构时）。如以下示例所示，您可以在模块的 build.gradle 文件中定义一个属性，使其对清单和代码均可用，而不必在多个位置更新同一属性以反映更改。如需了解详情，请阅读将构建变量注入清单。
//android {
//  // For settings specific to a product flavor, configure these properties
//  // for each flavor in the productFlavors block.
//  defaultConfig {
//    // Creates a property for the FileProvider authority.
//    def filesAuthorityValue = applicationId + ".files"
//    // Creates a placeholder property to use in the manifest.
//    manifestPlaceholders =
//      [filesAuthority: filesAuthorityValue]
//      // Adds a new field for the authority to the BuildConfig class.
//      buildConfigField("String",
//                       "FILES_AUTHORITY",
//                       "\"${filesAuthorityValue}\"")
//  }
//  ...
//}
//...
//在清单中，按如下方式访问占位符：
//<manifest>
//  ...
//  <application>
//    ...
//    <provider
//      android:name="android.support.v4.content.FileProvider"
//      android:authorities="${filesAuthority}"
//      android:exported="false"
//      android:grantUriPermissions="true">
//      ...
//    </provider>
//  </application>
//</manifest>
//您可以按照如下所示，在应用代码中访问 FILES_AUTHORITY 字段：
//Uri contentUri = FileProvider.getUriForFile(getContext(),
//  BuildConfig.FILES_AUTHORITY,
//  myFile);

//在库模块的build.gradle中，您需要几行额外的代码来告诉它导出风味，以及如果从另一个模块中包含时未指定，则默认使用哪个build变体：
//android {
//    defaultPublishConfig "productionRelease"
//    publishNonDefault true
//    productFlavors {
//        alpha {
//        }
//        production {
//        }
//    }
//}
//publishNonDefault仅当某人想要依赖于productionRelease变体以外的其他东西时，才需要使用该位。如果首先在库中设置了多种口味，则可能是这种情况。
//现在，如果您通过它的build.gradle中的另一个模块添加了一个依赖项：
//dependencies {
//    compile project(':module')
//}
//productionRelease默认情况下，它取决于变量。如果您想使用非默认变体：
//dependencies {
//    compile project(path: ':module', configuration:'alphaDebug')
//}
//implementation project(path: ':share_library_temp', configuration: 'a16')

//Release和Debug的区别
//Apk
//主要区别在于调试标志和签名密钥：
//对于调试版本，将使用启用了调试标志的默认调试签名密钥对apk进行签名。
//对于发布密钥，您将必须明确指定用于签名的密钥，并且调试标志将关闭，以便无法对其进行调试。
//可以为发布版本打开Proguard。（也适用于调试版本，但不建议使用）。此步骤需要明确完成，默认情况下为false。
//发行版apk必须先解压缩，然后手动修改，再由调试证书重新压缩+签名，以便其他人可以调试。每个用户总是可以访问代码，发布是“模糊的”而不是“阻止的”。您不能向必须向用户隐藏代码的用户，该用户必须能够运行该代码，在某个阶段该代码必须对用户可用，并且此时熟练的用户可以复制该代码并进行探索/反向工程。“混淆”只会使过程更加困难。
//调试版本实际上是一个完全自包含的apk版本，它甚至可以部署在生产环境中，但缺乏一些代码压缩/优化/缩小以及开发人员的限制。身份验证。
//请注意，代码收缩会减慢构建时间，因此，如果可能，应避免在调试构建中使用它。但是，务必在用于测试的最终APK上启用代码收缩功能，因为如果您没有充分自定义要保留的代码，它可能会引入错误。
//如果我们使用debug.apk将该应用程序安装在设备/模拟器上，则可以
//*使用调试器调试
//*使用android studio profiler配置cpu，内存，网络
//*请参阅logcat中的日志
//*使用布局检查器调试布局
//如果使用，release.apk我们将无法使用上述功能，并且我们将某些功能/库配置为以特定的输出类型工作（就像我们只能在debug apk中使用leakCanary）
//Build
//检查您是否在Java文件中使用了诸如BuildConfig.DEBUG之类的东西。那一定是造成问题的原因。
//我曾经面临着同样的问题。我发现我正在使用类似的代码if(BuildConfig.DEBUG) { Toast(...); }。那是我的问题。我将其更改为if(!BuildConfig.DEBUG) { Toast(...); }使我的应用程序可以在该应用程序的发行版中工作。
//也许问题与APK的签署有关。如果使用，debuggable true则使用通用调试密钥库对应用程序进行签名，并且一切正常。相反，如果将其删除，则必须提供
//storeFile file("myreleasekey.keystore")
//storePassword "password"
//keyAlias "MyReleaseKey"
//keyPassword "password"
//49
//让我感到困惑的是，当我调试该应用程序时，它运行良好并输出“ notNULL”。我可以看到该对象的每个属性均已正确反序列化。但是，当我从Android Studio生成已发布的apk并在手机上运行apk时，输出“ isNULL”，则json解析失败！
//您的release构建类型-中已启用ProGuard minifyEnabled true。它通过更改类/变量名称来混淆代码。
//您应该注释您的类属性，以便Gson知道要查找的内容：
//public class ReturnData {
//    @SerializedName("reply_code")
//    public String reply_code;
//    @SerializedName("userinfo")
//    public userinfo userinfo;
//}
//public class userinfo {
//    @SerializedName("username")
//    public String username;
//    @SerializedName("userip")
//    public String userip;
//}
//这样，Gson不会查看属性的名称，而是会查看@SerializedName注释。
//创建应用程序时，您使用调试版本进行工作（开发应用程序）。
//•应用就绪后，您将部署（发布到商店）发行版本。
//•版本构建始终更快，更优化，因为它不包含任何调试信息。
//•调试版本包含其他信息，可帮助您开发应用程序，因此它可能比发行版版本慢。此外，它的大小可能更大，当然，您不想将调试信息部署到用户，更不用说使反向工程变得更加简单。
//•您用于应用程序的库的构建类型无关。尽管您所使用的库的开发人员可以为您提供调试和发布版本，以帮助您进行开发，但它们始终应作为发行版进行部署。如果它们为您提供了两种变体，则采用与上述相同的逻辑，并且Android Studio将根据您当前的构建类型选择正确的逻辑。
//您可以（应该）在项目中使用库的发行版。它与您的项目构建变体无关，因为您没有使用库源代码，而是使用编译后的输出。
//关于您的项目/应用程序，您应该将Debug变体用于调试目的Release，例如，当您已经想在Play商店等市场中发布应用时，应使用变体。
//是的，在发布模式下的性能要比调试更高，因为在应用程序运行时不再运行许多额外的日志。当项目是一个拥有数百个类和库的大型项目时，这尤其明智。
//Android应用程序构建会引发发布错误，调试不会
//-为什么快速修复不是真正的解决方案-
//您可以将此选项放在build.gradle部分的android块中
//        lintOptions {
//          checkReleaseBuilds false
//        }
//曾经面对这个问题，这是一个APPT2问题（至少在我的情况下）。从共享的屏幕截图中，它告诉您重复的资源。在执行js捆绑并且创建了几个包含资源的文件夹之后，可能会发生这种情况。
//以下是我如何处理APPT2问题的方法：
//尝试浏览至（android / app / build / intermediates / res / merged / release /
//查看是否有任何drawable- *文件夹
//执行 rm -rf android/app/build/intermediates/res/merged/release/drawable-*)
//再试一次./gradlew assembleRelease（您可能仍然无法在此处构建）
//回到同一文件夹，删除.DS_Store
//再次建立
//希望成功
//猜您添加的某些依赖项中有appcompat-v4导致错误的信息，不太确定
//可能的解决方案：
//尝试删除zip4j_1.3.2.jar，然后再次添加 compile 'com.android.support:appcompat-v7:24.2.0'
//@ th3pat3l提出的一个：添加
//compile (compile 'com.android.support:appcompat-v7:25.0.0') {
//    exclude module: 'support-v4'
//}
//Api版本> 14的提示：
//避免使用jar，因为它们是打包的，您几乎不能更改它们，而是尝试通过添加一个简单的项目在build.gradle文件中使用它们 compile ''xxx.xx.xx
//导入旧的Eclipse项目时，我也遇到了此类问题。它在项目中作为jar文件出现了一些旧的依赖关系。
//第一种方法只是删除
//compile fileTree(dir: 'libs', include: '*.jar')
//在gradle文件中
//并在gradle文件中添加依赖项。
//这个对我有用 ..
//第二种方法您现在可能已经修复了此问题，但是请确保将其解决，请尝试将其添加到您的 build.gradle:
//configurations {
//    all*.exclude group: 'com.android.support', module: 'support-v4'
//}